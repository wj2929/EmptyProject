namespace Microsoft.VisualStudio.TextTemplating
{
    using Microsoft.VisualStudio.TextTemplating.CodeDom;
    using Microsoft.VisualStudio.TextTemplating.Properties;
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections.Generic;
    using System.Globalization;
    using System.IO;
    using System.Linq;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization;
    using System.Security.Cryptography;
    using System.Text;
    using System.Threading;

    public class Engine : ITextTemplatingEngine
    {
        private const string AssemblyDirectiveName = "assembly";
        public const string CacheAssembliesOptionString = "CacheAssemblies";
        private CompilerErrorCollection errors = new CompilerErrorCollection();
        private static MD5 hasher = MD5.Create();
        private const string ImportDirectiveName = "import";
        private const string IncludeDirectiveName = "include";
        private const string MethodName = "TransformText";
        private const string OutputDirectiveName = "output";
        private const string TemplateDirectiveName = "template";

        private void AddAutoGeneratedComment(CodeNamespace codeNamespace)
        {
            codeNamespace.Comments.Add(new CodeCommentStatement("------------------------------------------------------------------------------"));
            codeNamespace.Comments.Add(new CodeCommentStatement("<auto-generated>"));
            codeNamespace.Comments.Add(new CodeCommentStatement("    " + Resources.AutoGenCommentLine1));
            codeNamespace.Comments.Add(new CodeCommentStatement("    " + string.Format(CultureInfo.InvariantCulture, Resources.AutoGenCommentLine2, new object[] { base.GetType().Assembly.GetName().Version })));
            codeNamespace.Comments.Add(new CodeCommentStatement(" "));
            codeNamespace.Comments.Add(new CodeCommentStatement("    " + Resources.AutoGenCommentLine3));
            codeNamespace.Comments.Add(new CodeCommentStatement("    " + Resources.AutoGenCommentLine4));
            codeNamespace.Comments.Add(new CodeCommentStatement("</auto-generated>"));
            codeNamespace.Comments.Add(new CodeCommentStatement("------------------------------------------------------------------------------"));
        }

        private void AddGeneratedCodeAttribute(CodeTypeDeclaration generatorType)
        {
            generatorType.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(GeneratedCodeAttribute)), new CodeAttributeArgument[] { new CodeAttributeArgument(new CodePrimitiveExpression("Microsoft.VisualStudio.TextTemplating")), new CodeAttributeArgument(new CodePrimitiveExpression(base.GetType().Assembly.GetName().Version.ToString())) }));
        }

        private static void AddHostProperty(CodeTypeDeclaration generatorType)
        {
            CodeMemberField field = new CodeMemberField(typeof(ITextTemplatingEngineHost), "hostValue") {
                Type = { Options = CodeTypeReferenceOptions.GlobalReference },
                Attributes = MemberAttributes.Private
            };
            generatorType.Members.Add(field);
            CodeMemberProperty property = new CodeMemberProperty {
                Name = "Host",
                Type = new CodeTypeReference(typeof(ITextTemplatingEngineHost), CodeTypeReferenceOptions.GlobalReference),
                Attributes = MemberAttributes.Public,
                HasGet = true,
                HasSet = true
            };
            property.GetStatements.Add(new CodeMethodReturnStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "hostValue")));
            property.SetStatements.Add(new CodeAssignStatement(new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), "hostValue"), new CodePropertySetValueReferenceExpression()));
            generatorType.Members.Add(property);
        }

        private static void AddInitializeMethod(TemplateProcessingSession session, StringBuilder directivesBuilder, StringBuilder preInitBuilder, StringBuilder postInitBuilder)
        {
            StringBuilder sb = new StringBuilder();
            CodeMemberMethod member = new CodeMemberMethod {
                Name = "Initialize"
            };
            MemberAttributes attributes = ProvideBaseClassOverrideAttribute(session);
            member.Attributes = attributes | MemberAttributes.Public;
            if (preInitBuilder.Length != 0)
            {
                CodeSnippetStatement statement = new CodeSnippetStatement(preInitBuilder.ToString());
                member.Statements.Add(statement);
            }
            if ((attributes & MemberAttributes.Override) == MemberAttributes.Override)
            {
                member.Statements.Add(new CodeMethodInvokeExpression(new CodeBaseReferenceExpression(), member.Name, new CodeExpression[0]));
            }
            if (postInitBuilder.Length != 0)
            {
                CodeConditionStatement statement2 = new CodeConditionStatement(new CodeBinaryOperatorExpression(new CodePropertyReferenceExpression(new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "Errors"), "HasErrors"), CodeBinaryOperatorType.ValueEquality, new CodePrimitiveExpression(false)), new CodeStatement[] { new CodeSnippetStatement(postInitBuilder.ToString()) });
                member.Statements.Add(statement2);
            }
            CodeGeneratorOptions options = new CodeGeneratorOptions {
                BlankLinesBetweenMembers = true,
                IndentString = "    ",
                VerbatimOrder = true,
                BracingStyle = "C"
            };
            using (StringWriter writer = new StringWriter(sb, session.FormatProvider))
            {
                session.CodeDomProvider.GenerateCodeFromMember(member, writer, options);
            }
            directivesBuilder.AppendLine(sb.ToString());
        }

        private static void AddStatementWithLinePragma(TemplateProcessingSession session, CodeStatementCollection statements, Block block, CodeStatement statement)
        {
            int lineNumber = (block.StartLineNumber > 0) ? block.StartLineNumber : 1;
            AddStatementWithLinePragma(session, statements, lineNumber, block.FileName, statement);
        }

        private static void AddStatementWithLinePragma(TemplateProcessingSession session, CodeStatementCollection statements, int lineNumber, string fileName, CodeStatement statement)
        {
            bool flag = string.IsNullOrEmpty(fileName) && (session.Language == SupportedLanguages.CSharp);
            if (flag)
            {
                statements.Add(new CodeSnippetStatement("#line " + lineNumber));
            }
            else
            {
                statement.LinePragma = new CodeLinePragma(fileName, lineNumber);
            }
            statements.Add(statement);
            if (flag)
            {
                statements.Add(new CodeSnippetStatement("#line default"));
            }
        }

        private static void AddTypeMemberWithLinePragma(TemplateProcessingSession session, CodeTypeDeclaration generatorType, Block block, CodeSnippetTypeMember member)
        {
            bool flag = string.IsNullOrEmpty(block.FileName) && (session.Language == SupportedLanguages.CSharp);
            int lineNumber = (block.StartLineNumber > 0) ? block.StartLineNumber : 1;
            if (flag)
            {
                generatorType.Members.Add(new CodeSnippetTypeMember("#line " + lineNumber));
            }
            else
            {
                member.LinePragma = new CodeLinePragma(block.FileName, lineNumber);
            }
            generatorType.Members.Add(member);
            if (flag)
            {
                generatorType.Members.Add(new CodeSnippetTypeMember("#line default"));
            }
        }

        private static IEnumerable<Type> CollateSessionTypes(ITextTemplatingSession userTransformationSession)
        {
            List<Type> list = new List<Type>();
            Type candidate = userTransformationSession.GetType();
            if (NonStandardType(candidate))
            {
                list.Add(candidate);
            }
            foreach (object obj2 in userTransformationSession.Values)
            {
                Type type = obj2.GetType();
                if (NonStandardType(type))
                {
                    list.Add(type);
                }
            }
            return list;
        }

        private string CompileAndRunCode(string generatorCode, ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            string errorOutput = Resources.ErrorOutput;
            AppDomain domain = null;
            try
            {
                domain = host.ProvideTemplatingAppDomain(generatorCode);
            }
            catch (Exception exception)
            {
                if (IsCriticalException(exception))
                {
                    throw;
                }
            }
            if (domain == null)
            {
                this.LogError(session.TemplateFile, -1, -1, Resources.NoAppDomain, false);
                return errorOutput;
            }
            AssemblyResolver resolver = new AssemblyResolver();
            domain.AssemblyResolve += new ResolveEventHandler(resolver.AssemblyResolve);
            try
            {
                ObjectHandle handle = domain.CreateInstance(base.GetType().Assembly.FullName, typeof(TransformationRunner).FullName);
                if (handle != null)
                {
                    TransformationRunner runner = (TransformationRunner) handle.Unwrap();
                    if (runner == null)
                    {
                        return errorOutput;
                    }
                    this.ResolveAssemblyReferences(host, session);
                    if (this.errors.HasErrors)
                    {
                        return errorOutput;
                    }
                    runner.PreLoadAssemblies(session.AssemblyDirectives.ToArray());
                    ITextTemplatingEngineHost host2 = null;
                    if (session.HostSpecific)
                    {
                        host2 = host;
                    }
                    try
                    {
                        runner.RunTransformation(session, generatorCode, host2, out errorOutput);
                    }
                    catch (SerializationException)
                    {
                        this.LogError(session.TemplateFile, -1, -1, Resources.SessionHostMarshalError, false);
                        throw;
                    }
                    this.errors.AddRange(runner.Errors);
                }
                return errorOutput;
            }
            catch (AppDomainUnloadedException)
            {
                this.LogError(session.TemplateFile, -1, -1, Resources.NoAppDomain, false);
            }
            catch (Exception exception2)
            {
                if (IsCriticalException(exception2))
                {
                    throw;
                }
                this.LogError(session.TemplateFile, -1, -1, Resources.ExceptionWhileRunningCode + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception2.ToString() }), false);
            }
            finally
            {
                domain.AssemblyResolve -= new ResolveEventHandler(resolver.AssemblyResolve);
            }
            return errorOutput;
        }

        private static void ConstructBaseClassOptions(TemplateProcessingSession session, CodeTypeDeclaration generatorType, string className, out CodeTypeDeclaration baseClass)
        {
            baseClass = null;
            if (!string.IsNullOrEmpty(session.BaseClassName))
            {
                generatorType.BaseTypes.Add(new CodeTypeReference(session.BaseClassName));
            }
            else if (!session.Preprocess)
            {
                generatorType.BaseTypes.Add(new CodeTypeReference(typeof(TextTransformation)));
            }
            else
            {
                string name = className.Trim() + "Base";
                baseClass = TextTransformation.ProvideBaseClass(name);
                generatorType.BaseTypes.Add(new CodeTypeReference(name));
            }
        }

        private string ConstructGeneratorCode(ITextTemplatingEngineHost host, List<Block> blocks, TemplateProcessingSession session, bool insertLineNumbers, string className, string namespaceName)
        {
            CodeTypeDeclaration declaration2;
            if (string.IsNullOrEmpty(className))
            {
                className = "GeneratedTextTransformation";
            }
            if (string.IsNullOrEmpty(namespaceName) && !session.Preprocess)
            {
                namespaceName = "Microsoft.VisualStudio.TextTemplating";
                namespaceName = CreateUniqueNamespaceName(session, namespaceName, host, blocks);
            }
            session.ClassFullName = namespaceName + "." + className;
            CodeNamespace codeNamespace = new CodeNamespace(namespaceName);
            if (session.Preprocess)
            {
                this.AddAutoGeneratedComment(codeNamespace);
            }
            foreach (string str in session.ImportDirectives)
            {
                if (!string.IsNullOrEmpty(str))
                {
                    codeNamespace.Imports.Add(new CodeNamespaceImport(str));
                }
            }
            CodeTypeDeclaration generatorType = new CodeTypeDeclaration(className);
            if (session.Preprocess)
            {
                this.AddGeneratedCodeAttribute(generatorType);
            }
            generatorType.IsClass = true;
            generatorType.IsPartial = session.Preprocess;
            codeNamespace.Types.Add(generatorType);
            ConstructBaseClassOptions(session, generatorType, className, out declaration2);
            if (session.Preprocess && (declaration2 != null))
            {
                this.AddGeneratedCodeAttribute(declaration2);
                codeNamespace.Types.Add(declaration2);
                declaration2.Members.AddRange(ToStringHelper.ProvideHelpers(session.FormatProvider));
            }
            if (!string.IsNullOrEmpty(session.TemplateFile) && (session.Language == SupportedLanguages.CSharp))
            {
                generatorType.LinePragma = new CodeLinePragma(session.TemplateFile, 1);
            }
            ConstructTransformTextMethod(session, blocks, insertLineNumbers, generatorType);
            if (session.HostSpecific)
            {
                AddHostProperty(generatorType);
            }
            CodeGeneratorOptions options = new CodeGeneratorOptions {
                VerbatimOrder = true,
                BlankLinesBetweenMembers = false,
                BracingStyle = "C"
            };
            bool firstClassFeatureFound = false;
            foreach (Block block in blocks)
            {
                firstClassFeatureFound = GenerateMemberForBlock(session, block, generatorType, insertLineNumbers, options, firstClassFeatureFound);
            }
            CodeDomProvider codeDomProvider = session.CodeDomProvider;
            using (StringWriter writer = new StringWriter(session.FormatProvider))
            {
                try
                {
                    codeDomProvider.GenerateCodeFromNamespace(codeNamespace, new IndentedTextWriter(writer), options);
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(session.TemplateFile, -1, -1, Resources.ErrorGeneratingTranformationClass + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
                }
                return writer.ToString();
            }
        }

        private static CodeStatementCollection ConstructStatementsForGeneratorMethod(List<Block> blocks, TemplateProcessingSession session, bool insertLineNumbers)
        {
            CodeStatementCollection statements2;
            CodeStatementCollection statements = new CodeStatementCollection();
            foreach (Block block in blocks)
            {
                if (block.Type == BlockType.Directive)
                {
                    continue;
                }
                if (block.Type == BlockType.ClassFeature)
                {
                    break;
                }
                if (block.Type == BlockType.Statement)
                {
                    CodeSnippetStatement statement = new CodeSnippetStatement(block.Text);
                    if (insertLineNumbers)
                    {
                        AddStatementWithLinePragma(session, statements, block, statement);
                    }
                    else
                    {
                        statements.Add(statement);
                    }
                    continue;
                }
                if (block.Type == BlockType.BoilerPlate)
                {
                    if (!string.IsNullOrEmpty(block.Text))
                    {
                        CodeMethodInvokeExpression expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Write", new CodeExpression[] { new CodePrimitiveExpression(block.Text) });
                        statements.Add(expression);
                    }
                }
                else
                {
                    CodeMethodInvokeExpression expression2 = new CodeMethodInvokeExpression(GetToStringHelperReference(session), "ToStringWithCulture", new CodeExpression[] { new CodeArgumentReferenceExpression(block.Text.Trim()) });
                    CodeMethodInvokeExpression expression3 = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Write", new CodeExpression[] { expression2 });
                    CodeExpressionStatement statement2 = new CodeExpressionStatement(expression3);
                    if (insertLineNumbers)
                    {
                        AddStatementWithLinePragma(session, statements, block, statement2);
                        continue;
                    }
                    statements.Add(statement2);
                }
            }
            if (session.Preprocess)
            {
                statements2 = statements;
            }
            else
            {
                statements2 = new CodeStatementCollection();
                CodeTryCatchFinallyStatement statement3 = new CodeTryCatchFinallyStatement();
                statements2.Add(statement3);
                statement3.TryStatements.AddRange(statements);
                CodeCatchClause clause = new CodeCatchClause("e");
                statement3.CatchClauses.Add(clause);
                clause.Statements.Add(new CodeIndexerExpression(new CodeVariableReferenceExpression("e").Prop("Data"), new CodeExpression[] { "TextTemplatingProgress".Prim() }).Assign(new CodeThisReferenceExpression().Prop("GenerationEnvironment").Call("ToString", new CodeExpression[0])));
                clause.Statements.Add(new CodeThrowExceptionStatement());
            }
            statements2.Add(new CodeMethodReturnStatement(new CodeThisReferenceExpression().Prop("GenerationEnvironment").Call("ToString", new CodeExpression[0])));
            return statements2;
        }

        private static void ConstructTransformTextMethod(TemplateProcessingSession session, List<Block> blocks, bool insertLineNumbers, CodeTypeDeclaration generatorType)
        {
            CodeMemberMethod method = new CodeMemberMethod();
            generatorType.Members.Add(method);
            method.Name = "TransformText";
            method.Attributes = ProvideBaseClassOverrideAttribute(session) | MemberAttributes.Public;
            method.ReturnType = new CodeTypeReference(typeof(string));
            method.Statements.AddRange(ConstructStatementsForGeneratorMethod(blocks, session, insertLineNumbers));
        }

        private static string CreateUniqueNamespaceName(TemplateProcessingSession session, string baseNamespaceName, ITextTemplatingEngineHost host, List<Block> blocks)
        {
            object hostOption = null;
            try
            {
                hostOption = host.GetHostOption("CacheAssemblies");
            }
            catch (Exception exception)
            {
                if (IsCriticalException(exception))
                {
                    throw;
                }
            }
            session.CacheAssemblies = ((hostOption != null) && (hostOption is bool)) && ((bool) hostOption);
            if (session.CacheAssemblies)
            {
                StringBuilder textToHash = new StringBuilder();
                blocks.ForEach(delegate (Block block) {
                    textToHash.AppendLine(block.Text);
                });
                byte[] bytes = Encoding.UTF8.GetBytes(textToHash.ToString());
                byte[] buffer2 = hasher.ComputeHash(bytes);
                StringBuilder builder = new StringBuilder();
                for (int i = 0; i < buffer2.Length; i++)
                {
                    builder.Append(buffer2[i].ToString("X2", CultureInfo.InvariantCulture));
                }
                baseNamespaceName = baseNamespaceName + builder.ToString();
                return baseNamespaceName;
            }
            baseNamespaceName = baseNamespaceName + Guid.NewGuid().ToString("N");
            return baseNamespaceName;
        }

        private static bool GenerateMemberForBlock(TemplateProcessingSession session, Block block, CodeTypeDeclaration generatorType, bool insertLineNumbers, CodeGeneratorOptions options, bool firstClassFeatureFound)
        {
            CodeSnippetTypeMember member = null;
            if (block.Type == BlockType.ClassFeature)
            {
                firstClassFeatureFound = true;
                if (!string.IsNullOrEmpty(block.Text))
                {
                    member = new CodeSnippetTypeMember(block.Text);
                }
            }
            else
            {
                if ((block.Type == BlockType.BoilerPlate) && firstClassFeatureFound)
                {
                    CodeMethodInvokeExpression expression = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Write", new CodeExpression[] { new CodePrimitiveExpression(block.Text) });
                    CodeExpressionStatement statement = new CodeExpressionStatement(expression);
                    using (StringWriter writer = new StringWriter(session.FormatProvider))
                    {
                        session.CodeDomProvider.GenerateCodeFromStatement(statement, writer, options);
                        member = new CodeSnippetTypeMember(writer.ToString());
                        goto Label_0148;
                    }
                }
                if ((block.Type == BlockType.Expression) && firstClassFeatureFound)
                {
                    CodeMethodInvokeExpression expression2 = new CodeMethodInvokeExpression(GetToStringHelperReference(session), "ToStringWithCulture", new CodeExpression[] { new CodeArgumentReferenceExpression(block.Text.Trim()) });
                    CodeMethodInvokeExpression expression3 = new CodeMethodInvokeExpression(new CodeThisReferenceExpression(), "Write", new CodeExpression[] { expression2 });
                    CodeExpressionStatement statement2 = new CodeExpressionStatement(expression3);
                    using (StringWriter writer2 = new StringWriter(session.FormatProvider))
                    {
                        session.CodeDomProvider.GenerateCodeFromStatement(statement2, writer2, options);
                        member = new CodeSnippetTypeMember(writer2.ToString());
                    }
                }
            }
        Label_0148:
            if (member != null)
            {
                if (insertLineNumbers)
                {
                    AddTypeMemberWithLinePragma(session, generatorType, block, member);
                    return firstClassFeatureFound;
                }
                generatorType.Members.Add(member);
            }
            return firstClassFeatureFound;
        }

        private Type GetLocalCustomDirectiveProcessor(Directive directive)
        {
            if (string.IsNullOrEmpty(directive.DirectiveProcessorName) && (StringComparer.OrdinalIgnoreCase.Compare("parameter", directive.DirectiveName) == 0))
            {
                directive.SetDirectiveProcessorName("ParameterDirectiveProcessor");
                return typeof(ParameterDirectiveProcessor);
            }
            return null;
        }

        private static CodeExpression GetToStringHelperReference(TemplateProcessingSession session)
        {
            if (session.Preprocess)
            {
                return new CodePropertyReferenceExpression(new CodeThisReferenceExpression(), "ToStringHelper");
            }
            return new CodeTypeReferenceExpression(typeof(ToStringHelper).FullName);
        }

        private static void InitializeSessionWithHostData(ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            try
            {
                session.TemplateFile = host.TemplateFile;
            }
            catch (NotImplementedException)
            {
                session.TemplateFile = string.Empty;
            }
            session.IncludeStack.Push(session.TemplateFile);
            ITextTemplatingSessionHost host2 = host as ITextTemplatingSessionHost;
            if (host2 != null)
            {
                session.UserTransformationSession = host2.Session;
            }
        }

        private static bool IsBuiltInDirective(Directive directive)
        {
            if (((string.Compare(directive.DirectiveName, "include", StringComparison.OrdinalIgnoreCase) != 0) && (string.Compare(directive.DirectiveName, "assembly", StringComparison.OrdinalIgnoreCase) != 0)) && (((string.Compare(directive.DirectiveName, "import", StringComparison.OrdinalIgnoreCase) != 0) && (string.Compare(directive.DirectiveName, "template", StringComparison.OrdinalIgnoreCase) != 0)) && (string.Compare(directive.DirectiveName, "output", StringComparison.OrdinalIgnoreCase) != 0)))
            {
                return false;
            }
            return true;
        }

        internal static bool IsCriticalException(Exception e)
        {
            return ((((e is StackOverflowException) || (e is OutOfMemoryException)) || (e is ThreadAbortException)) || ((e.InnerException != null) && IsCriticalException(e.InnerException)));
        }

        private bool IsSupportedLanguage(Directive directive, string languageParameterFromDirective, string expectedLangauge, string notSupportedLanguage)
        {
            if (languageParameterFromDirective.StartsWith(expectedLangauge, StringComparison.OrdinalIgnoreCase))
            {
                if (StringComparer.OrdinalIgnoreCase.Compare(languageParameterFromDirective, expectedLangauge) == 0)
                {
                    return true;
                }
                if (StringComparer.OrdinalIgnoreCase.Compare(languageParameterFromDirective, notSupportedLanguage) == 0)
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.CompilerVersionNotSupported, new object[] { expectedLangauge, languageParameterFromDirective.Substring(expectedLangauge.Length) }), true);
                    return true;
                }
            }
            return false;
        }

        private void LogError(Block block, string errorText, bool isWarning)
        {
            string fileName = "";
            if (!string.IsNullOrEmpty(block.FileName))
            {
                fileName = block.FileName;
            }
            this.LogError(fileName, block.StartLineNumber, block.StartColumnNumber, errorText, isWarning);
        }

        private void LogError(string fileName, int line, int column, string errorText, bool isWarning)
        {
            CompilerError error = new CompilerError(fileName, line, column, null, errorText) {
                IsWarning = isWarning
            };
            this.errors.Add(error);
        }

        private static bool NonStandardType(Type candidate)
        {
            Assembly assembly = candidate.Assembly;
            return (!candidate.IsPrimitive && !assembly.GlobalAssemblyCache);
        }

        public string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, out string language, out string[] references)
        {
            string str;
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (host == null)
            {
                throw new ArgumentNullException("host");
            }
            if (string.IsNullOrEmpty(className))
            {
                throw new ArgumentNullException("className");
            }
            if (classNamespace == null)
            {
                classNamespace = string.Empty;
            }
            TemplateProcessingSession session = new TemplateProcessingSession {
                TemplateContents = content,
                Preprocess = true
            };
            InitializeSessionWithHostData(host, session);
            this.errors.Clear();
            try
            {
                str = this.ProcessTemplateImplementation(session, content, host, className, classNamespace);
            }
            finally
            {
                language = session.Language.ToString();
                references = session.AssemblyDirectives.ToArray();
            }
            return str;
        }

        private void ProcessAssemblyDirective(Directive directive, TemplateProcessingSession session)
        {
            string str;
            if (directive.Parameters.TryGetValue("name", out str))
            {
                session.AssemblyDirectives.Add(str);
            }
            else
            {
                this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NotEnoughDirectiveParameters, new object[] { "name", directive.DirectiveName }), false);
            }
        }

        private List<Block> ProcessBuiltInDirective(Directive directive, ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            if (string.Compare(directive.DirectiveName, "include", StringComparison.OrdinalIgnoreCase) == 0)
            {
                return this.ProcessIncludeDirective(directive, host);
            }
            if (string.Compare(directive.DirectiveName, "assembly", StringComparison.OrdinalIgnoreCase) == 0)
            {
                this.ProcessAssemblyDirective(directive, session);
            }
            else if (string.Compare(directive.DirectiveName, "import", StringComparison.OrdinalIgnoreCase) == 0)
            {
                this.ProcessImportDirective(directive, session);
            }
            else if (string.Compare(directive.DirectiveName, "template", StringComparison.OrdinalIgnoreCase) == 0)
            {
                if (!session.ProcessedTemplateDirective)
                {
                    this.ProcessTemplateDirective(directive, session);
                    session.ProcessedTemplateDirective = true;
                }
                else
                {
                    this.LogError(directive.Block, Resources.MultipleTemplateDirectives, true);
                }
            }
            else if (string.Compare(directive.DirectiveName, "output", StringComparison.OrdinalIgnoreCase) == 0)
            {
                if (!session.ProcessedOutputDirective)
                {
                    this.ProcessOutputDirective(directive, host);
                    session.ProcessedOutputDirective = true;
                }
                else
                {
                    this.LogError(directive.Block, Resources.MultipleOutputDirectives, true);
                }
            }
            return new List<Block>(0);
        }

        private List<Directive> ProcessBuiltInDirectives(List<Block> blocks, ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            List<Directive> list = new List<Directive>();
            for (int i = 0; i < blocks.Count; i++)
            {
                Block block = blocks[i];
                if (block.Type == BlockType.Directive)
                {
                    goto Label_002E;
                }
                continue;
            Label_0022:
                session.IncludeStack.Pop();
            Label_002E:
                if ((session.IncludeStack.Count > 0) && (StringComparer.OrdinalIgnoreCase.Compare(session.IncludeStack.Peek(), block.FileName) != 0))
                {
                    goto Label_0022;
                }
                Directive directive = TemplateParser.ParseDirectiveBlock(block, this.errors);
                if (directive != null)
                {
                    if (IsBuiltInDirective(directive))
                    {
                        List<Block> list2 = this.ProcessBuiltInDirective(directive, host, session);
                        if ((list2 == null) || (list2.Count == 0))
                        {
                            continue;
                        }
                        if (session.IncludeStack.Contains(list2[0].FileName))
                        {
                            this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.RecursiveInclude, new object[] { list2[0].FileName }), true);
                            continue;
                        }
                        session.IncludeStack.Push(list2[0].FileName);
                        int count = 0;
                        while (count < list2.Count)
                        {
                            if (list2[count].Type == BlockType.ClassFeature)
                            {
                                break;
                            }
                            count++;
                        }
                        blocks.InsertRange(i + 1, list2.GetRange(0, count));
                        if (count < list2.Count)
                        {
                            blocks.AddRange(list2.GetRange(count, list2.Count - count));
                        }
                        continue;
                    }
                    list.Add(directive);
                }
            }
            return list;
        }

        private Dictionary<string, DirectiveProcessor> ProcessCustomDirectives(ITextTemplatingEngineHost host, TemplateProcessingSession session, List<Directive> directivesToBeProcessed)
        {
            Dictionary<string, DirectiveProcessor> dictionary = new Dictionary<string, DirectiveProcessor>(StringComparer.OrdinalIgnoreCase);
            Queue<Tuple<Directive, DirectiveProcessor>> queue = new Queue<Tuple<Directive, DirectiveProcessor>>();
            foreach (Directive directive in directivesToBeProcessed)
            {
                DirectiveProcessor processor;
                Type localCustomDirectiveProcessor = this.GetLocalCustomDirectiveProcessor(directive);
                if (string.IsNullOrEmpty(directive.DirectiveProcessorName))
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NoProcessorForDirective, new object[] { directive.DirectiveName }), false);
                    continue;
                }
                if (!dictionary.TryGetValue(directive.DirectiveProcessorName, out processor))
                {
                    try
                    {
                        if (localCustomDirectiveProcessor == null)
                        {
                            localCustomDirectiveProcessor = host.ResolveDirectiveProcessor(directive.DirectiveProcessorName);
                        }
                        if (localCustomDirectiveProcessor == null)
                        {
                            this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NoProcessorTypeForDirective, new object[] { directive.DirectiveProcessorName, directive.DirectiveName }), false);
                            continue;
                        }
                        if (!localCustomDirectiveProcessor.IsSubclassOf(typeof(DirectiveProcessor)))
                        {
                            this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.IncorrectDPType, new object[] { localCustomDirectiveProcessor, directive.DirectiveProcessorName }), false);
                            continue;
                        }
                    }
                    catch (Exception exception)
                    {
                        if (IsCriticalException(exception))
                        {
                            throw;
                        }
                        this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NoProcessorTypeForDirective, new object[] { directive.DirectiveProcessorName, directive.DirectiveName }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
                        continue;
                    }
                    try
                    {
                        processor = Activator.CreateInstance(localCustomDirectiveProcessor) as DirectiveProcessor;
                        if (processor == null)
                        {
                            this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.CannotInitializeProcessor, new object[] { localCustomDirectiveProcessor.ToString(), directive.DirectiveName }), false);
                            continue;
                        }
                        processor.Initialize(host);
                        IRecognizeHostSpecific specific = processor as IRecognizeHostSpecific;
                        if ((specific != null) && specific.RequiresProcessingRunIsHostSpecific)
                        {
                            session.HostSpecific = true;
                        }
                        processor.StartProcessingRun(session.CodeDomProvider, session.TemplateContents, this.errors);
                        dictionary[directive.DirectiveProcessorName] = processor;
                    }
                    catch (Exception exception2)
                    {
                        if (IsCriticalException(exception2))
                        {
                            throw;
                        }
                        this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.CannotInitializeProcessor, new object[] { localCustomDirectiveProcessor.ToString(), directive.DirectiveName }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception2.ToString() }), false);
                        continue;
                    }
                }
                if (processor != null)
                {
                    queue.Enqueue(new Tuple<Directive, DirectiveProcessor>(directive, processor));
                }
            }
            while (queue.Count > 0)
            {
                Tuple<Directive, DirectiveProcessor> tuple = queue.Dequeue();
                Directive directive2 = tuple.Item1;
                DirectiveProcessor processor2 = tuple.Item2;
                IRecognizeHostSpecific specific2 = processor2 as IRecognizeHostSpecific;
                if (specific2 != null)
                {
                    specific2.SetProcessingRunIsHostSpecific(session.HostSpecific);
                }
                try
                {
                    if (processor2.IsDirectiveSupported(directive2.DirectiveName))
                    {
                        processor2.ProcessDirective(directive2.DirectiveName, directive2.Parameters);
                    }
                    else
                    {
                        this.LogError(directive2.Block, string.Format(CultureInfo.CurrentCulture, Resources.ProcessorNotSupportDirective, new object[] { directive2.DirectiveProcessorName, directive2.DirectiveName }), false);
                    }
                }
                catch (Exception exception3)
                {
                    if (IsCriticalException(exception3))
                    {
                        throw;
                    }
                    this.LogError(directive2.Block, string.Format(CultureInfo.CurrentCulture, Resources.ExceptionProcessingDirective, new object[] { directive2.DirectiveName }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception3.ToString() }), false);
                }
            }
            return dictionary;
        }

        private void ProcessDirectives(List<Block> blocks, ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            List<Directive> directivesToBeProcessed = this.ProcessBuiltInDirectives(blocks, host, session);
            TemplateParser.StripExtraNewlines(blocks);
            Dictionary<string, DirectiveProcessor> dictionary = this.ProcessCustomDirectives(host, session, directivesToBeProcessed);
            StringBuilder directivesBuilder = new StringBuilder();
            StringBuilder preInitBuilder = new StringBuilder();
            StringBuilder postInitBuilder = new StringBuilder();
            foreach (string str in dictionary.Keys)
            {
                DirectiveProcessor processor = dictionary[str];
                try
                {
                    processor.FinishProcessingRun();
                    string preInitializationCodeForProcessingRun = processor.GetPreInitializationCodeForProcessingRun();
                    if (!string.IsNullOrEmpty(preInitializationCodeForProcessingRun))
                    {
                        preInitBuilder.AppendLine(preInitializationCodeForProcessingRun);
                    }
                    string postInitializationCodeForProcessingRun = processor.GetPostInitializationCodeForProcessingRun();
                    if (!string.IsNullOrEmpty(postInitializationCodeForProcessingRun))
                    {
                        postInitBuilder.AppendLine(postInitializationCodeForProcessingRun);
                    }
                    string classCodeForProcessingRun = processor.GetClassCodeForProcessingRun();
                    if (!string.IsNullOrEmpty(classCodeForProcessingRun))
                    {
                        directivesBuilder.AppendLine(classCodeForProcessingRun);
                    }
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(session.TemplateFile, -1, -1, string.Format(CultureInfo.CurrentCulture, Resources.ExceptionGettingProcessorOutput, new object[] { str }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
                }
                try
                {
                    string[] importsForProcessingRun = processor.GetImportsForProcessingRun();
                    if (importsForProcessingRun != null)
                    {
                        session.ImportDirectives.AddRange(importsForProcessingRun);
                    }
                    string[] referencesForProcessingRun = processor.GetReferencesForProcessingRun();
                    if (referencesForProcessingRun != null)
                    {
                        session.AssemblyDirectives.AddRange(referencesForProcessingRun);
                    }
                    continue;
                }
                catch (Exception exception2)
                {
                    if (IsCriticalException(exception2))
                    {
                        throw;
                    }
                    this.LogError(session.TemplateFile, -1, -1, string.Format(CultureInfo.CurrentCulture, Resources.ExceptionGettingReferencesFromDP, new object[] { str }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception2.ToString() }), false);
                    continue;
                }
            }
            try
            {
                IList<string> standardImports = host.StandardImports;
                if (standardImports != null)
                {
                    session.ImportDirectives.AddRange(standardImports);
                }
                IList<string> standardAssemblyReferences = host.StandardAssemblyReferences;
                if (standardAssemblyReferences != null)
                {
                    session.AssemblyDirectives.AddRange(standardAssemblyReferences);
                }
                if (session.HostSpecific)
                {
                    session.AssemblyDirectives.Add(typeof(ITextTemplatingEngineHost).Assembly.FullName);
                }
            }
            catch (Exception exception3)
            {
                if (IsCriticalException(exception3))
                {
                    throw;
                }
                this.LogError(session.TemplateFile, -1, -1, Resources.ExceptionGettingStandardReferences + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception3.ToString() }), false);
            }
            if ((preInitBuilder.Length != 0) || (postInitBuilder.Length != 0))
            {
                AddInitializeMethod(session, directivesBuilder, preInitBuilder, postInitBuilder);
            }
            if (directivesBuilder.Length != 0)
            {
                Block item = new Block(BlockType.ClassFeature, directivesBuilder.ToString()) {
                    FileName = session.TemplateFile
                };
                blocks.Add(item);
            }
        }

        private void ProcessImportDirective(Directive directive, TemplateProcessingSession session)
        {
            string str;
            if (directive.Parameters.TryGetValue("namespace", out str))
            {
                session.ImportDirectives.Add(str);
            }
            else
            {
                this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NotEnoughDirectiveParameters, new object[] { "namespace", directive.DirectiveName }), false);
            }
        }

        private List<Block> ProcessIncludeDirective(Directive directive, ITextTemplatingEngineHost host)
        {
            string str;
            if (directive.Parameters.TryGetValue("file", out str))
            {
                try
                {
                    string str2;
                    string str3;
                    str = Environment.ExpandEnvironmentVariables(str);
                    bool flag = host.LoadIncludeText(str, out str2, out str3);
                    if ((!flag && !Path.IsPathRooted(str)) && !string.IsNullOrEmpty(directive.Block.FileName))
                    {
                        string requestFileName = Path.Combine(Path.GetDirectoryName(directive.Block.FileName), str);
                        flag = host.LoadIncludeText(requestFileName, out str2, out str3);
                    }
                    if (!flag || string.IsNullOrEmpty(str2))
                    {
                        this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.BlankIncludeFile, new object[] { str }), false);
                        goto Label_0159;
                    }
                    return TemplateParser.ParseTemplateIntoBlocks(str2, str3, this.errors);
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.ErrorLoadingIncludeFile, new object[] { str }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
                    goto Label_0159;
                }
            }
            this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.NotEnoughDirectiveParameters, new object[] { "file", directive.DirectiveName }), false);
        Label_0159:
            return new List<Block>(0);
        }

        private void ProcessOutputDirective(Directive directive, ITextTemplatingEngineHost host)
        {
            string str;
            string str2;
            int num;
            if (directive.Parameters.TryGetValue("extension", out str))
            {
                try
                {
                    str = str.Trim();
                    if (!str.StartsWith(".", StringComparison.OrdinalIgnoreCase))
                    {
                        str = "." + str;
                    }
                    host.SetFileExtension(str);
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(directive.Block, Resources.ExceptionSettingExtension + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), true);
                }
            }
            if (!directive.Parameters.TryGetValue("encoding", out str2) || string.IsNullOrEmpty(str2))
            {
                return;
            }
            Encoding encoding = null;
            str2 = str2.Trim();
            if (int.TryParse(str2, out num))
            {
                try
                {
                    encoding = Encoding.GetEncoding(num);
                    goto Label_019C;
                }
                catch (Exception exception2)
                {
                    if (IsCriticalException(exception2))
                    {
                        throw;
                    }
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.EncodingIntegerFailed, new object[] { num }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception2.ToString() }), true);
                    goto Label_019C;
                }
            }
            try
            {
                encoding = Encoding.GetEncoding(str2);
            }
            catch (Exception exception3)
            {
                if (IsCriticalException(exception3))
                {
                    throw;
                }
                this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.EncodingStringFailed, new object[] { str2 }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception3.ToString() }), true);
            }
        Label_019C:
            if (encoding != null)
            {
                try
                {
                    host.SetOutputEncoding(encoding, true);
                }
                catch (Exception exception4)
                {
                    if (IsCriticalException(exception4))
                    {
                        throw;
                    }
                    this.LogError(directive.Block, Resources.EncodingStringFailed + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception4.ToString() }), true);
                }
            }
        }

        public string ProcessTemplate(string content, ITextTemplatingEngineHost host)
        {
            if (content == null)
            {
                throw new ArgumentNullException("content");
            }
            if (host == null)
            {
                throw new ArgumentNullException("host");
            }
            TemplateProcessingSession session = new TemplateProcessingSession {
                TemplateContents = content
            };
            InitializeSessionWithHostData(host, session);
            this.errors.Clear();
            return this.ProcessTemplateImplementation(session, content, host, null, null);
        }

        private void ProcessTemplateDirective(Directive directive, TemplateProcessingSession session)
        {
            string str;
            string str2;
            string str3;
            string str4;
            string str5;
            string str6;
            if (directive.Parameters.TryGetValue("language", out str))
            {
                if (this.IsSupportedLanguage(directive, str, "VB", "VBv3.5"))
                {
                    session.Language = SupportedLanguages.VB;
                }
                else if (this.IsSupportedLanguage(directive, str, "C#", "C#v3.5"))
                {
                    session.Language = SupportedLanguages.CSharp;
                }
                else
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.InvalidLanguage, new object[] { str }), true);
                }
            }
            if (directive.Parameters.TryGetValue("inherits", out str2))
            {
                session.BaseClassName = str2;
            }
            if (directive.Parameters.TryGetValue("culture", out str3))
            {
                try
                {
                    CultureInfo info = new CultureInfo(str3);
                    if (info.IsNeutralCulture)
                    {
                        this.LogError(directive.Block, Resources.InvalidNeutralCulture, true);
                        session.FormatProvider = CultureInfo.InvariantCulture;
                    }
                    else
                    {
                        session.FormatProvider = info;
                    }
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(directive.Block, Resources.InvalidCulture, true);
                    session.FormatProvider = CultureInfo.InvariantCulture;
                }
            }
            if (directive.Parameters.TryGetValue("debug", out str4))
            {
                bool flag;
                if (bool.TryParse(str4, out flag))
                {
                    session.Debug = flag;
                }
                else
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.InvalidDebugParam, new object[] { str4 }), true);
                }
            }
            if (directive.Parameters.TryGetValue("hostspecific", out str5))
            {
                bool flag2;
                if (bool.TryParse(str5, out flag2))
                {
                    session.HostSpecific = flag2;
                }
                else
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.InvalidHostSpecificParam, new object[] { str5 }), true);
                }
            }
            if (directive.Parameters.TryGetValue("compilerOptions", out str6))
            {
                if (File.Exists(str6) || Directory.Exists(str6))
                {
                    this.LogError(directive.Block, string.Format(CultureInfo.CurrentCulture, Resources.InvalidCompilerOption, new object[] { str6 }), false);
                }
                session.CompilerOptions = str6;
            }
        }

        private string ProcessTemplateImplementation(TemplateProcessingSession session, string content, ITextTemplatingEngineHost host, string className, string classNamespace)
        {
            string errorOutput = Resources.ErrorOutput;
            try
            {
                List<Block> blocks = TemplateParser.ParseTemplateIntoBlocks(content, session.TemplateFile, this.errors);
                if (this.errors.HasErrors)
                {
                    return errorOutput;
                }
                this.ProcessDirectives(blocks, host, session);
                if (this.errors.HasErrors)
                {
                    return errorOutput;
                }
                string generatorCode = errorOutput = this.ConstructGeneratorCode(host, blocks, session, true, className, classNamespace);
                if (session.Preprocess)
                {
                    return generatorCode;
                }
                return this.CompileAndRunCode(generatorCode, host, session);
            }
            catch (Exception exception)
            {
                if (IsCriticalException(exception))
                {
                    throw;
                }
                this.LogError(session.TemplateFile, -1, -1, Resources.ExceptionProcessingTemplate + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
            }
            finally
            {
                session.IncludeStack.Clear();
                host.LogErrors(this.errors);
            }
            return errorOutput;
        }

        private static MemberAttributes ProvideBaseClassOverrideAttribute(TemplateProcessingSession session)
        {
            if (session.Preprocess && string.IsNullOrEmpty(session.BaseClassName))
            {
                return (MemberAttributes) 0;
            }
            return MemberAttributes.Override;
        }

        private void ResolveAssemblyReferences(ITextTemplatingEngineHost host, TemplateProcessingSession session)
        {
            if (session.UserTransformationSession != null)
            {
                IEnumerable<Type> source = CollateSessionTypes(session.UserTransformationSession);
                session.AssemblyDirectives.AddRange(source.Select<Type, string>(delegate (Type t) {
                    if (!t.Assembly.GlobalAssemblyCache)
                    {
                        return t.Assembly.Location;
                    }
                    return t.Assembly.FullName;
                }));
            }
            List<string> collection = new List<string>(session.AssemblyDirectives.Distinct<string>());
            session.AssemblyDirectives.Clear();
            session.AssemblyDirectives.AddRange(collection);
            for (int i = 0; i < session.AssemblyDirectives.Count; i++)
            {
                try
                {
                    session.AssemblyDirectives[i] = host.ResolveAssemblyReference(Environment.ExpandEnvironmentVariables(session.AssemblyDirectives[i]));
                }
                catch (Exception exception)
                {
                    if (IsCriticalException(exception))
                    {
                        throw;
                    }
                    this.LogError(session.TemplateFile, -1, -1, string.Format(CultureInfo.CurrentCulture, Resources.ExceptionResolvingAssembly, new object[] { session.AssemblyDirectives[i] }) + string.Format(CultureInfo.CurrentCulture, Resources.Exception, new object[] { exception.ToString() }), false);
                }
            }
        }
    }
}

